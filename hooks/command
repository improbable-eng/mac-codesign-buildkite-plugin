#!/usr/bin/env bash
#
# Actually signs the package.
# 1. Retrieve the unsigned binary from the BK artifact store
# 2. Retrieve the keychain unlock password
# 3. Unlock the keychain
# 4. Sign the binary and validate the signature
# 5. Upload the binary as a BuildKite artifact

set -e -o pipefail
[[ -n "${DEBUG-}" ]] && set -x

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/shared.sh
source "${DIR}/../lib/shared.sh"

codesigning_keychain="${BUILDKITE_PLUGIN_MAC_CODESIGN_KEYCHAIN}"
script_root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
default_keychain_pw_helper_script="${script_root_dir}/../helpers/fetch-keychain-pw.sh"

# Fetch the artifact and put it in the target dir
# Params:
#   fetch_target: Name of the BuildKite artifact to fetch
#   dest_dir: Where to download it to.
function fetch_artifact() {
  fetch_target="${1}"
  dest_dir="${2}"

  buildkite-agent artifact download "${fetch_target}" "${dest_dir}"
  retval=$?
  if [[ "${retval}" -ne 0 ]]; then
    echo "Unable to download the specified artifact '${fetch_target}' with error code '${retval}'"
    exit 1
  fi

  echo "${dest_dir}/${fetch_target}"
}

# If the unlock secret was not supplied as an env var, call the helper script to fetch it
# Params:
#   helper_script_path: Path to a script to run that returns the keychain PW.
#   helper_script_arg: Any arguments that need to be passed to the helper script.
function get_keychain_pw() {
  helper_script_path="${1}"
  helper_script_arg="${2}"

  if [[ -z "${KEYCHAIN_PW}" ]]; then
    KEYCHAIN_PW="$("${helper_script_path}" "${helper_script_arg}")"
    retval=$?
    if [[ "${retval}" -ne 0 || -z "${KEYCHAIN_PW}" ]]; then
      echo "Unable the fetch the secret using the helper script: error code '${retval}'"
      exit 2
    fi
  fi

  echo "${KEYCHAIN_PW}"
}

# Now unlock the keychain and find the identity to sign with
# Params:
#   keychain_name: The name of an existing, accessible macos Keychain containing one signing certificate.
#   keychain_pw: The password to unlock this keychain.
function unlock_keychain() {
  keychain_name=${1}
  keychain_pw=${2}

  security unlock-keychain -p "${keychain_pw}" "${keychain_name}"
  retval=$?
  if [[ "${retval}" -ne 0 ]]; then
    echo "Unable to unlock the requested keychain '${keychain_name}': error code '${retval}'"
    exit 3
  fi
}

# Generate gon config for signing+notarisation
# Params:
#   input: File to sign+notarise
#   signed_dir_fragment: path to store any new files generated by this step in
function generate_signing_config() {
  input="${1}"
  signed_dir_fragment="${2}"

  config=$(jq -n \
    --arg input "${input}" \
    --arg bundle_id "${BUILDKITE_PLUGIN_MAC_CODESIGN_TOOL_BUNDLE_ID}" \
    --arg apple_user_email "${BUILDKITE_PLUGIN_MAC_CODESIGN_APPLE_USER_EMAIL}" \
    --arg identity "${BUILDKITE_PLUGIN_MAC_CODESIGN_KEY_WANTED}" \
    '{
      "source": [$input],
      "bundle_id": $bundle_id,
      "apple_id": {
        "username": $apple_user_email,
        "password": "@keychain:apple_password",
      },
      "sign": {
        "application_identity": $identity,
      },
    }')

  # Generate DMG files if relevant
  tool_name="${BUILDKITE_PLUGIN_MAC_CODESIGN_TOOL_NAME}"
  if [[ -n "${tool_name}" ]]; then
    dmg_name="${BUILDKITE_PLUGIN_MAC_CODESIGN_TOOL_DMG_NAME}"
    if [[ -z "${dmg_name}" ]]; then
      dmg_name="${tool_name}.dmg"
    fi

    config="$(
      echo "${config}" | jq \
        --arg name "${tool_name}" \
        --arg path "${signed_dir_fragment}/${dmg_name}" \
        '"dmg": {
          "volume_name": $name,
          "output_path": $path,
        }'
    )"
  fi

  echo "${config}"
}

# Generate gon config for notarisation
# Params:
#   input: File to notarise
function generate_notarisation_config() {
  input="${1}"

  jq -n \
    --arg input "${input}" \
    --arg bundle_id "${BUILDKITE_PLUGIN_MAC_CODESIGN_TOOL_BUNDLE_ID}" \
    --arg apple_user_email "${BUILDKITE_PLUGIN_MAC_CODESIGN_APPLE_USER_EMAIL}" \
    '{
      "notarize": [
        {
        "path": $input,
        "bundle_id": $bundle_id,
        "staple": true,
        }
      ],
      "apple_id": {
        "username": $apple_user_email,
        "password": "@keychain:apple_password",
      },
    }'
}

# Sign the binary
# Params:
#   signing_target: The unsigned item to sign.
#   signed_dir_fragment: path to store any new files generated by this step in
function sign_and_validate() {
  signing_target="${1}"
  signed_dir_fragment="${2}"

  config_path="${signed_dir_fragment}/config.json"
  if [[ "${signing_target}" == *.pkg ]]; then
    # PKG files need to be signed with "developer ID Installer" certs through `productsign`.
    # `gon` only supports "Application" certs, through `codesign`.
    # This steps signs with productsign, and then generates a gon config to notarize it.
    echo "${signing_target}: signing pkg"
    signed_artifact="$(basename "${signing_target}")"

    echo "${signing_target}: signing PKG file"
    productsign --sign "${BUILDKITE_PLUGIN_MAC_CODESIGN_KEY_WANTED}" "${signing_target}" "${signed_dir_fragment}/${signed_artifact}"
    retval=$?
    if [[ "${retval}" -ne 0 ]]; then
      echo "productsigning of target '${signing_target}' failed: error code '${retval}'"
      exit 4
    fi

    output_file="${signed_artifact}"

    echo "${signing_target}: generating package notarisation config"
    generate_notarisation_config "${signed_artifact}" >"${config_path}"
  else
    output_file="${signing_target}"

    echo "${signing_target}: generating code signing + notarisation config"
    generate_signing_config "${signing_target}" "${signed_dir_fragment}" >"${config_path}"
  fi

  # Use `gon` config generated in earlier steps to sign (if necessary) and notarise.
  echo "${signing_target}: executing gon on generated config"
  gon --log-level=info "${config_path}"
  retval=$?
  if [[ "${retval}" -ne 0 ]]; then
    echo "codesigning of target '${signing_target}' failed: error code '${retval}'"
    exit 4
  fi

  echo "${output_file}"
}

# Convenience wrapper to upload our signed artifact to BuildKite
# Params:
#   artifact: Path of a file to upload to BuildKite as an artifact.
function upload_artifact() {
  artifact="${1}"

  buildkite-agent artifact upload "${artifact}"
  retval=$?
  if [[ "${retval}" -ne 0 ]]; then
    echo "Unable to upload ${artifact} to BuildKite: error code '${retval}'"
    exit 6
  fi
}

# Allow the user to override the default keychain pw retrieval helper script.
function find_keychain_pw_helper_script() {
  if [[ -n "${BUILDKITE_PLUGIN_MAC_CODESIGN_KEYCHAIN_PW_HELPER_SCRIPT}" ]]; then
    script="${BUILDKITE_PLUGIN_MAC_CODESIGN_KEYCHAIN_PW_HELPER_SCRIPT}"
  else
    script="${default_keychain_pw_helper_script}"
  fi

  echo "${script}"
}

## Main execution flow

# Set everything up to be able to sign.
echo "--- Getting the password to unlock the keychain"
keychain_pw_helper_script=$(find_keychain_pw_helper_script)
keychain_pw=$(get_keychain_pw "${keychain_pw_helper_script}")

echo "--- Unlocking the keychain"
unlock_keychain "${codesigning_keychain}" "${keychain_pw}"

echo "--- Setting up local directories"
# Download things in a local dir to identify them
artifact_dir_fragment="artifacts"
rm -rf "${artifact_dir_fragment}" && mkdir -p "${artifact_dir_fragment}"
relative_artifacts_dir="$(pwd)/${artifact_dir_fragment}"

# Signed things go in a local dir so the uploaded artifacts don't have a weird path
signed_dir_fragment="signed"
rm -rf "${signed_dir_fragment}" && mkdir -p "${signed_dir_fragment}"

# Download and sign each requested artifact
for artifact in $(plugin_read_list INPUT_ARTIFACTS); do
  echo "--- Signing ${artifact}"

  echo "${artifact}: retrieving unsigned artifact"
  unsigned_artifact="$(fetch_artifact "${artifact}" "${relative_artifacts_dir}")"

  echo "${artifact}: signing + notarising artifact"
  signed_artifact="$(sign_and_validate "${unsigned_artifact}" "${signed_dir_fragment}")"

  signed_file="$(basename "${signed_artifact}")"

  echo "${signed_file}: uploading signed artifact"
  # Move the signed file to the "signed/" directory for uploading with a normal-looking name.
  # This way, the uploaded artifacts in BK will all be named "signed/$ARTIFACT_FILENAME"
  mv "${signed_artifact}" "${signed_dir_fragment}/${signed_file}"
  upload_artifact "${signed_dir_fragment}/**/*"
  popd
done
