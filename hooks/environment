#!/usr/bin/env bash
#
# This script sets up the environment needed to perform code signing.
# 0. Ensure that this job is allowed to proceed with codesigning stuff.
# 1. Find the signing cert on disk.
# 2. Get the password to decrypt it from Vault.
# 3. Create a temporary keychain, import the signing cert into it, then lock the keychain with a rand pw.
# 4. Export the codesigning identity ID and the keychain password so the rest of this job can sign with them.

signing_cert_name="${BUILDKITE_PLUGIN_MAC_CODESIGN_SIGNING_CERT}"
pw_secret="${BUILDKITE_PLUGIN_MAC_CODESIGN_SIGNING_CERT_PW_SECRET}"

# TODO: Make this be a useful path.
cert_store_root_path="/Users/sean/src/cert-root"
# TODO: Make this be the actual signing host, not my laptop.
permitted_signing_host="sean-mac-c02xv3a8jgh6"
codesign_keychain="${BUILDKITE_PLUGIN_MAC_CODESIGN_KEYCHAIN}:-codesign.keychain"
cert_pw=""
signing_cert_path="${cert_store_root_path}/${signing_cert_name}"

# Verify that this is only running on MacOS, via BuildKite, in proper CI, on our blessed agent.
validate_environment() {
  if [[ "${BUILDKITE}" != "true" ]]; then
    echo "Code signing can only be done as part of a BuildKite pipeline."
    exit 1
  fi

  if [[ "${BUILDKITE_SOURCE}" == "local" ]]; then
    echo "Code signing is not allowed to be done locally."
    exit 1
  fi

  if [[ "${BUILDKITE_AGENT_META_DATA_PLATFORM}" != "macos" ]]; then
    echo "Code signing can only be performed on macos."
    exit 1
  fi

  if [[ "${BUILDKITE_AGENT_META_DATA_HOSTNAME}" != "${permitted_signing_host}" ]]; then
    echo "Code signing can only be performed on specific permitted agents."
    exit 1
  fi

  if [[ ! -r "${signing_cert_path}" ]]; then
    echo "Unable to read specified signing cert ${signing_cert} in ${cert_store_root_path}"
    return 1
  else
    echo "Found cert!"
    cat "${signing_cert_path}"
  fi
}

# Retrieve the pw for the signing cert from Vault.
# Required param: 
#   name of the secret to retrieve from Vault
retrieve_signing_cert_pw() {
  cert_pw=$(imp-vault read-key --key="${1}")
  if [[ $? -ne 0 || "${cert_pw}" == "" ]]; then
    echo "Unable to read secret for specified secret ${1}"
    return 1
  else
    echo "Successfully read secret from Vault"
    echo "${cert_pw}"
  fi
}

# Set up the temporary codesigning keychain.
# Required param: 
#   name of the keychain to create
create_codesign_keychain() {
  # Randomly generate a secure pw for the keychain.
  export KEYCHAIN_NAME="${1}"
  export KEYCHAIN_PW="$(head /dev/urandom | LC_ALL=C tr -dc A-Za-z0-9 | head -c 16)"
  
  # If the keychain already exists, warn the user and then delete it so we start fresh.
  security list-keychains | grep "${1}"
  if [[ $? -ne 0  ]]; then
    echo "WARNING: The keychain ${1} already exists.  Removing it and creating a new empty keychain."
    security delete-keychain "${1}"
  fi
  
  # Now create the keychain and add it to the search list.  create-keychain claims to do this, but it lies.
  security create-keychain -p "${KEYCHAIN_PW}" "${1}"
  security list-keychains -d user -s login.keychain "${1}"
}

# Adds a certificate to a keychain
# Required params: 
#   Path to the certificate to be added.
#   Name of the keychain to add to.
#   Password to decrypt the certificate.
add_certificate_to_keychain() {
  # '-T' allows codesign to use this cert without requiring further password input.
  security import "${1}" -k "${2}" -P "${cert_pw}" -T /usr/bin/codesign
  
  # Ugh, this is so awful, but we need to get some portion of the identity out of the keychain, and there's no clean way to do it.
  export CODESIGN_IDENTITY="$(security find-identity codesign.keychain | grep -A1 "Valid identities" | tail -1 | awk '{print $2}')"
  
  # Lock it up, juuuuust in case.
  security lock-keychain "${2}"
}

validate_environment
retrieve_signing_cert_pw "${pw_secret}"
create_codesign_keychain "${codesign_keychain}"
add_certificate_to_keychain "${signing_cert_path}" "${codesign_keychain}" "${cert_pw}"
